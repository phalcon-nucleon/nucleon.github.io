<div class="row">
  <div class="col s12">
    <ul class="summary generate"></ul>
  </div>
  <div class="col s12">
    <blockquote>
      <p>Here we just saw Nucleon addition, and basic usage.<br/>
        <a href="https://docs.phalconphp.com/en/3.3/db-models" target="_blank">Read the full phalcon model documentation here</a></p>
    </blockquote>

    <h2>Working with Models</h2>
    <p>A model represents the information (data) of the application and the rules to manipulate that data.
      Models are primarily used for managing the rules of interaction with a corresponding database table.
      In most cases, each table in your database will correspond to one model in your application.
      The bulk of your application's business logic will be concentrated in the models.</p>

    <p><code>Neutrino\Model</code> is the base for all models in a Nucleon application. <code>Neutrino\Model</code> extend the <code>Phalcon\Mvc\Model</code> class.
      It provides database independence, basic CRUD functionality, advanced finding capabilities, and the ability to relate models to one another, among other services.
      <code>Neutrino\Model</code> avoids the need of having to use SQL statements because it translates methods dynamically to the respective database engine operations.</p>

    <h3>Creating Model</h3>
    <p>Models are stored in the <code>app/Core/Models</code> directory.<br/>
    This is a proposal place to store models. You can place your models any where, or add a level if your application as many model type,
      like <code>Entity</code>, <code>Dto</code>, <code>Document</code>, ...</p>
    <pre><code>namespace App\Core\Models;

use Neutrino\Model;

class User extends Model
{

}</code></pre>

    <h3>Define Table / Columns / Relationship</h3>
    <p>The definition of the model can be done automatically by phalcon, however it implies that an SQL query is done for each model, at each initialization.</p>
    <p>To avoid this request, and thus improve the performances, we will define ourselves the structure in the <code>initialize</code> method.</p>

    <p>The <code>initialize</code> method will be a single time during the execution.</p>
    <pre><code>class User extends Model
{
    public function initialize() {
        parent::initialize();
    }
}</code></pre>

    <h5>Define the table</h5>
    <p>The <code>setSource</code> method should be use to define the table for the model.</p>
    <pre><code>class User extends Model
{
    public function initialize() {
        parent::initialize();

        $this->setSource('users');
    }
}</code></pre>

    <h5>Define Columns</h5>
    <p>The <code>column</code> method should be use to define the columns.</p>

    <pre><code>use Phalcon\Column;

class User extends Model
{
    public function initialize() {
        parent::initialize();

        $this->setSource('users');
        $this->primary('id', Column::TYPE_INTEGER);
        $this->column('name', Column::TYPE_VARCHAR);
        $this->column('email', Column::TYPE_VARCHAR);
        $this->column('password', Column::TYPE_VARCHAR);
        $this->column('remember_token', Column::TYPE_VARCHAR, [
            'nullable' => true
        ]);
    }
}</code></pre>

    <p>The first argument is the primary column name.</p>
    <p>The second argument is the type of column.</p>
    <table class="small">
      <thead>
      <tr>
        <th>Const</th>
        <th>Description</th>
      </tr>
      </thead>
      <tbody>
      <tr>
        <td><code>Column::TYPE_INTEGER</code></td>
        <td>Integer abstract type</td>
      </tr>
      <tr>
        <td><code>Column::TYPE_DATE</code></td>
        <td>Date abstract type</td>
      </tr>
      <tr>
        <td><code>Column::TYPE_VARCHAR</code></td>
        <td>Varchar abstract type</td>
      </tr>
      <tr>
        <td><code>Column::TYPE_DECIMAL</code></td>
        <td>Decimal abstract type</td>
      </tr>
      <tr>
        <td><code>Column::TYPE_DATETIME</code></td>
        <td>Datetime abstract type</td>
      </tr>
      <tr>
        <td><code>Column::TYPE_CHAR</code></td>
        <td>Char abstract type</td>
      </tr>
      <tr>
        <td><code>Column::TYPE_TEXT</code></td>
        <td>Text abstract data type</td>
      </tr>
      <tr>
        <td><code>Column::TYPE_FLOAT</code></td>
        <td>Float abstract data type</td>
      </tr>
      <tr>
        <td><code>Column::TYPE_BOOLEAN</code></td>
        <td>Boolean abstract data type</td>
      </tr>
      <tr>
        <td><code>Column::TYPE_DOUBLE</code></td>
        <td>Double abstract data type</td>
      </tr>
      <tr>
        <td><code>Column::TYPE_TINYBLOB</code></td>
        <td>Tinyblob abstract data type</td>
      </tr>
      <tr>
        <td><code>Column::TYPE_BLOB</code></td>
        <td>Blob abstract data type</td>
      </tr>
      <tr>
        <td><code>Column::TYPE_MEDIUMBLOB</code></td>
        <td>Mediumblob abstract data type</td>
      </tr>
      <tr>
        <td><code>Column::TYPE_LONGBLOB</code></td>
        <td>Longblob abstract data type</td>
      </tr>
      <tr>
        <td><code>Column::TYPE_BIGINTEGER</code></td>
        <td>Big integer abstract data type</td>
      </tr>
      <tr>
        <td><code>Column::TYPE_JSON</code></td>
        <td>Json abstract type</td>
      </tr>
      <tr>
        <td><code>Column::TYPE_JSONB</code></td>
        <td>Json blob abstract type</td>
      </tr>
      </tbody>
    </table>

    <p>The third argument of the <code>column</code> method, accept an of options for define particularity of column :</p>
    <table class="small">
      <thead>
      <tr>
        <th>Option</th>
        <th>Description</th>
      </tr>
      </thead>
      <tbody>
      <tr>
        <td><code style="white-space: nowrap">'default' => $value</code></td>
        <td>Applies default value at create on column</td>
      </tr>
      <tr>
        <td><code style="white-space: nowrap">'nullable' => true</code></td>
        <td>Allow to have an empty value on column</td>
      </tr>
      <tr>
        <td><code style="white-space: nowrap">'map' => $property</code></td>
        <td>Define to property to fill on Model. If empty, the property will be the same of the column name.</td>
      </tr>
      <tr><th colspan="2">Primary Only</th></tr>
      <tr>
        <td><code style="white-space: nowrap">'autoIncrement' => true</code></td>
        <td>Specify if the primary key is auto increment by the SGBD</td>
      </tr>
      <tr>
        <td><code style="white-space: nowrap">'multiple' => true</code></td>
        <td>Specify if the primary key is a multiple column key</td>
      </tr>
      </tbody>
    </table>


    <h5>Define the Primary Key</h5>
    <p>The <code>primary</code> method should be use to define the primary column used.</p>

    <pre><code>use Phalcon\Column;

class User extends Model
{
    public function initialize() {
        parent::initialize();

        $this->setSource('users');
        $this->primary('id', Column::TYPE_INTEGER);
    }
}</code></pre>

    <h5>Define a Multiple Primary Key</h5>
    <p>For define a primary key with multiple column, you should use the <code>primary</code> method on each primary column, with the option <code>multiple</code></p>

    <pre><code>
use Phalcon\Column;

class BookAuthor extends Model
{
    public function initialize() {
        parent::initialize();

        $this->setSource('books_authors');
        $this->primary('book_id', Column::TYPE_INTEGER, ['multiple' => true]);
        $this->primary('author_id', Column::TYPE_INTEGER, ['multiple' => true]);
    }
}</code></pre>

    <h3>Public properties vs. Setters/Getters</h3>
    <p>Models can be implemented public properties,
      meaning that each property can be read/updated from any part of the code that has instantiated that model class:</p>
    <pre><code>class User extends Model
{
    public $id;

    public $name;

    public $email;
}</code></pre>

    <p>Another implementation is to use getters and setter functions, which control which properties are publicly available for that model. The benefit of using getters and setters is that the developer can perform transformations and validation checks on the values set for the model, which is impossible when using public properties. Additionally getters and setters allow for future changes without changing the interface of the model class. So if a field name changes, the only change needed will be in the private property of the model referenced in the relevant getter/setter and nowhere else in the code.</p>

    <pre><code>class User extends Model
{
    protected $id;

    protected $name;

    protected $email;

    public function getId()
    {
        return $this->id;
    }

    public function setId($id)
    {
        if ($id < 0) {
            throw new \InvalidArgumentException("Id can't be negative");
        }
        $this->id = $id;

        return $this;
    }

    public function getName()
    {
        return $this->name;
    }

    public function setName($name)
    {
        $len = strlen($name);

        if ($len < 4) {
            throw new \InvalidArgumentException("Name is too short");
        }
        if ($len > 32) {
            throw new \InvalidArgumentException("Name is too long");
        }
        $this->name = $name;

        return $this;
    }

    public function getEmail()
    {
        return $this->email;
    }

    public function setEmail($email)
    {
        if (!filter_var($email, FILTER_VALIDATE_EMAIL)) {
            throw new \InvalidArgumentException("Email is invalid");
        }
        $this->email = $email;

        return $this;
    }
}</code></pre>
    <p>Public properties provide less complexity in development. However getters/setters can heavily increase the testability, extensibility and maintainability of applications. Developers can decide which strategy is more appropriate for the application they are creating, depending on the needs of the application. The ORM is compatible with both schemes of defining properties.</p>

    <h2>Finding Records</h2>
    <h3>Model::find</h3>
    <h3>Model::findFirst</h3>
    <h3>Model::findBy{$property}</h3>
    <h3>Model::findFirstBy{$property}</h3>
    <h3>Model::findFirst</h3>
    <h3>Model::query</h3>
  </div>
</div>